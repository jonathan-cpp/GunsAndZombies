#pragma once

//////////////////////////////////////////////////////////
// Standard Library Headers
//////////////////////////////////////////////////////////

#include <iostream>
#include <random>

//////////////////////////////////////////////////////////
// Thirdparty Headers
//////////////////////////////////////////////////////////

#include <SFML/Graphics.hpp>

//////////////////////////////////////////////////////////
// Project Headers
//////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////

static constexpr float PI = 3.14159265359f;
static constexpr float ONE_DEGREE = PI / 180.f;
static constexpr float ONE_RADIAN = 180.f / PI;

static std::random_device g_random_device;
static std::mt19937 g_random_generator(g_random_device());

//---------------------------------------------------------------------------------------------------------------
template <typename T>
inline auto lerp(const T& current, const T& target, float lerpFactor) {
    return current + (target - current) * lerpFactor;
};
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
template <typename T>
inline auto ease(const T& t) {
    return ((6 * t - 15) * t + 10) * t * t * t;
};
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline sf::Vector2f normalize(const sf::Vector2f& vector) {
    float length = std::hypot(vector.x, vector.y);
    if (length != 0.0f) {
        return sf::Vector2f(vector.x / length, vector.y / length);
    }
    return vector; // Avoid division by zero
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline float dot(const sf::Vector2f& right, const sf::Vector2f& left) {
    return right.x * left.x + right.y * left.y;
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline sf::Vector2f rotate(const sf::Vector2f& vec, float angle) {
    return sf::Vector2f(std::cos(angle) * vec.x - std::sin(angle) * vec.y, std::sin(angle) * vec.x + std::cos(angle) * vec.y);
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline float distance(const sf::Vector2f& p1, const sf::Vector2f& p2) {
    float dx = p2.x - p1.x;
    float dy = p2.y - p1.y;
    return std::sqrt(dx * dx + dy * dy);
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline float length(const sf::Vector2f& vec) {
    return std::sqrt(vec.x * vec.x + vec.y * vec.y);
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline float radians(float degrees) {
    return degrees * ONE_DEGREE;
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline float degrees(float radians) {
    return radians * ONE_RADIAN;
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline int random(int a, int b) {
    std::uniform_int_distribution<int> dist(a, b);
    return dist(g_random_generator);
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline float random(float a, float b) {
    std::uniform_real_distribution<float> dist(a, b);
    return dist(g_random_generator);
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline double random() {
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    return dist(g_random_generator);
}
//---------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------
inline sf::Color randomColor() {
    return sf::Color(
        static_cast<uint8_t>(random() * 255.f),
        static_cast<uint8_t>(random() * 255.f),
        static_cast<uint8_t>(random() * 255.f), 
        255U
    );
}
//---------------------------------------------------------------------------------------------------------------
